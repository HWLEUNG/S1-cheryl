import React, { useState, useEffect, useRef } from 'react';
import { 
  BookOpen, Volume2, ArrowRight, Dices, 
  Trophy, User, Star, Crown, Swords, ShieldAlert, ShieldCheck, Home, ArrowUpCircle, Music, VolumeX, Link
} from 'lucide-react';

// --- æ•¸æ“šæº (ç¬¬10-40é …) ---
const FULL_DATA = [
  { id: 10, word: "ä¸€è‘‰çŸ¥ç§‹", meaning: "å½¢å®¹å¾å¾®å°çš„äº‹ç‰©ä¾¿æ¨æ–·å‡ºçµæœã€‚" },
  { id: 11, word: "ä¸€è½åƒä¸ˆ", meaning: "åœ°ä½åè²æˆ–äº‹ç‰©å¢ƒæ³æ€¥é€Ÿä¸‹æ»‘ã€‚" },
  { id: 12, word: "å…¥æœ¨ä¸‰åˆ†", meaning: "æ¯”å–»è­°è«–è¦‹è§£éå¸¸æ·±åˆ»ã€ç²¾é—¢ã€‚" },
  { id: 13, word: "ä¹æ­»ä¸€ç”Ÿ", meaning: "å½¢å®¹è™•å¢ƒéå¸¸å±éšªï¼Œæ­»è£é€ƒç”Ÿã€‚" },
  { id: 14, word: "å…«é¢å¨é¢¨", meaning: "å½¢å®¹äººæˆ–äº‹æ°£å‹¢é›„å£¯ï¼Œå¨é¢¨å‡œå‡œã€‚" },
  { id: 15, word: "äººå‚‘åœ°éˆ", meaning: "å½¢å®¹ç§€éº—çš„åœ°æ–¹ï¼Œå­•è‚²å‡ºå‚‘å‡ºäººæ‰ã€‚" },
  { id: 16, word: "åŠ›ä¸å¾å¿ƒ", meaning: "æŒ‡å…§å¿ƒæƒ³åšäº‹ï¼Œä½†èƒ½åŠ›ä¸è¶³ã€‚" },
  { id: 17, word: "ä¸‰æ€è€Œè¡Œ", meaning: "å–»åšäº‹æƒ…å‰è¦å¤šæ¬¡æ·±å…¥è€ƒæ…®æ‰å¯¦è¡Œã€‚" },
  { id: 18, word: "äº¡ç¾Šè£œç‰¢", meaning: "å–»çŠ¯éŒ¯å¾Œï¼Œç«‹å³æƒ³è¾¦æ³•è£œæ•‘ï¼Œä»¥é˜²é‡è¹ˆè¦†è½ã€‚" },
  { id: 19, word: "å¤§ç¾©æ»…è¦ª", meaning: "ç¶­è­·æ­£ç¾©ï¼Œä¸å¾‡ç§ï¼Œä¸è¢’è­·å­å¥³è¦ªæ—ã€‚" },
  { id: 20, word: "å¤§ç™¼é›·éœ†", meaning: "å½¢å®¹éå¸¸æ†¤æ€’ï¼Œå¤§ç™¼è„¾æ°£ã€‚" },
  { id: 21, word: "ä¸Šè¡Œä¸‹æ•ˆ", meaning: "å½¢å®¹ä¸Šç´šæ€æ¨£åšï¼Œä¸‹ç´šè·Ÿè‘—ä»¿æ•ˆã€‚" },
  { id: 22, word: "å¤§å¹å¤§æ“‚", meaning: "æ¯”å–»å¹å™“æˆ–å®£æšã€‚" },
  { id: 23, word: "å¤§é€†ä¸é“", meaning: "å½¢å®¹è¡Œç‚ºå›é€†ï¼Œé•èƒŒå¸¸ç†ï¼Œéå¸¸ä¸é“å¾·ã€‚" },
  { id: 24, word: "å£æ˜¯å¿ƒé", meaning: "æŒ‡å£ä¸­èªªå¾—å¥½è½ï¼Œå¿ƒä¸­æƒ³çš„æ˜¯å¦ä¸€å¥—ã€‚" },
  { id: 25, word: "å£èœœè…¹åŠ", meaning: "å£ä¸­èªªçš„ç”œç¾å‹•è½ï¼Œå¿ƒä¸­å»å­˜è‘—å®³äººçš„æ­¹å¿µã€‚" },
  { id: 26, word: "å£è‹¥æ‡¸æ²³", meaning: "æŒ‡èƒ½è¨€å–„è¾¯ï¼Œèªªè©±æ»”æ»”ä¸çµ•ã€‚" },
  { id: 27, word: "åƒéˆä¸€é«®", meaning: "å½¢å®¹å½¢å‹¢å±æ€¥æˆ–æƒ…æ³å±éšªã€‚" },
  { id: 28, word: "åƒéŒ˜ç™¾ç…‰", meaning: "å½¢å®¹åšäº‹ç¶“éå¤šæ¬¡åå¾©ï¼Œé”åˆ°ç²¾ç›Šæ±‚ç²¾çš„æ•ˆæœã€‚" },
  { id: 29, word: "åƒè¼‰é›£é€¢", meaning: "å½¢å®¹é›£å¾—ä¸€é‡çš„æ©Ÿæœƒã€‚" },
  { id: 30, word: "åƒè®Šè¬åŒ–", meaning: "è¡¨ç¤ºè®ŠåŒ–å¤šç«¯ã€‚" },
  { id: 31, word: "äº•åº•ä¹‹è›™", meaning: "å½¢å®¹è¦‹èç‹¹çª„ï¼Œçœ¼å…‰çŸ­æ·ºã€‚" },
  { id: 32, word: "æ–‡è³ªå½¬å½¬", meaning: "å½¢å®¹æ‰å¾·å…¼å…·ï¼Œæ‰è¯åŠè¡Œç‚ºå¾ˆæ°ç•¶ã€‚" },
  { id: 33, word: "å¤©å€«ä¹‹æ¨‚", meaning: "æŒ‡äº«å—è¦ªå±¬é–“çš„æ­¡æ¨‚ã€‚" },
  { id: 34, word: "å¤©é¦¬è¡Œç©º", meaning: "æ¯”å–»æ‰æ€æ•æ·è±ªæ”¾ï¼Œè©©æ–‡æ°£å‹¢è±ªæ”¾ã€‚" },
  { id: 35, word: "äº”åæ­¥ç¬‘ç™¾æ­¥", meaning: "æ¯”å–»è‡ªå·±æœ‰åŒæ¨£ç¼ºé»ï¼Œå»è­ç¬‘åˆ¥äººã€‚" },
  { id: 36, word: "å¤©èŠ±äº‚å¢œ", meaning: "å½¢å®¹èªªè©±è¨€è©å·§å¦™ï¼Œå¤šæŒ‡èª‡å¤§è€Œä¸åˆ‡å¯¦éš›ã€‚" },
  { id: 37, word: "å¤©ç¶“åœ°ç¾©", meaning: "æŒ‡å­˜åœ¨æ–¼å¤©åœ°é–“ï¼Œä¸å®¹ç½®ç–‘çš„æº–å‰‡å’ŒçœŸç†ã€‚" },
  { id: 38, word: "å¤©è¡£ç„¡ç¸«", meaning: "æŒ‡äº‹ç‰©ååˆ†å‘¨å¯†å®Œå–„ï¼Œæ‰¾ä¸å‡ºç ´ç¶»ã€‚" },
  { id: 39, word: "å¤©çœŸçˆ›æ¼«", meaning: "å½¢å®¹æ€§æƒ…ç´”çœŸã€å¦ç‡ï¼Œæ²’æœ‰é€ ä½œã€‚" },
  { id: 40, word: "äº”é«”æŠ•åœ°", meaning: "å¼•ç”³å½¢å®¹å°åˆ¥äººååˆ†ä½©æœã€‚" }
];

const BOARD_SIZE = 28; 
const TARGET_IDIOMS_COUNT = 20;
const INITIAL_SCORE = 3000; // å†æ¬¡å¢åŠ åˆå§‹è³‡é‡‘ä»¥æ‡‰å°é€£é–æ‡²ç½°
const BUILD_COST = 200; 

const AUDIO_URLS = {
  bgm: "https://cdn.pixabay.com/audio/2022/05/27/audio_1808fbf07a.mp3",
  correct: "https://assets.mixkit.co/active_storage/sfx/2000/2000-preview.m4a",
  wrong: "https://assets.mixkit.co/active_storage/sfx/2003/2003-preview.m4a",
  shatter: "https://assets.mixkit.co/active_storage/sfx/2018/2018-preview.m4a",
  build: "https://assets.mixkit.co/active_storage/sfx/2004/2004-preview.m4a",
};

const speak = (text) => {
  if ('speechSynthesis' in window) {
    window.speechSynthesis.cancel();
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = 'zh-HK';
    utterance.rate = 0.8;
    const voices = window.speechSynthesis.getVoices();
    const cantoneseVoice = voices.find(v => v.lang.includes('HK') || v.name.includes('Cantonese'));
    if (cantoneseVoice) utterance.voice = cantoneseVoice;
    window.speechSynthesis.speak(utterance);
  }
};

export default function IdiomMonopolyDuel() {
  const [gameState, setGameState] = useState('menu'); 
  const [sessionIdioms, setSessionIdioms] = useState([]);
  const [boardTiles, setBoardTiles] = useState([]);
  const [studyIndex, setStudyIndex] = useState(0);

  const [turn, setTurn] = useState(1); 
  const [players, setPlayers] = useState({
    1: { pos: 0, score: INITIAL_SCORE, name: 'ç©å®¶ 1', color: 'bg-red-500', bg: 'bg-red-50', border: 'border-red-500', text: 'text-red-700' },
    2: { pos: 0, score: INITIAL_SCORE, name: 'ç©å®¶ 2', color: 'bg-blue-500', bg: 'bg-blue-50', border: 'border-blue-500', text: 'text-blue-700' }
  });
  
  const [diceValue, setDiceValue] = useState(1);
  const [isMoving, setIsMoving] = useState(false);
  const [modalContent, setModalContent] = useState(null); 
  const [currentEvent, setCurrentEvent] = useState(null);
  const [gameLog, setGameLog] = useState(["éŠæˆ²é–‹å§‹ï¼"]);

  // Audio State
  const [isMusicPlaying, setIsMusicPlaying] = useState(false);
  const bgmRef = useRef(null);

  useEffect(() => {
    bgmRef.current = new Audio(AUDIO_URLS.bgm);
    bgmRef.current.loop = true;
    bgmRef.current.volume = 0.3;
    return () => {
      if (bgmRef.current) {
        bgmRef.current.pause();
        bgmRef.current = null;
      }
    };
  }, []);

  useEffect(() => {
    if (bgmRef.current) {
      if (isMusicPlaying) {
        bgmRef.current.play().catch(e => console.log("Audio needed interaction:", e));
      } else {
        bgmRef.current.pause();
      }
    }
  }, [isMusicPlaying]);

  const toggleMusic = () => setIsMusicPlaying(!isMusicPlaying);
  const playSfx = (type) => {
    const audio = new Audio(AUDIO_URLS[type]);
    audio.volume = 0.6;
    audio.play().catch(e => console.log("SFX error:", e));
  };
  const addLog = (msg) => setGameLog(prev => [msg, ...prev].slice(0, 3));

  // --- åˆå§‹åŒ–éŠæˆ²é‚è¼¯ (æ›´æ–°åœ°åœ–ç”Ÿæˆ) ---
  const initGame = () => {
    const shuffled = [...FULL_DATA].sort(() => 0.5 - Math.random());
    const selected = shuffled.slice(0, TARGET_IDIOMS_COUNT);
    setSessionIdioms(selected);
    
    // åˆå§‹åŒ–ç©ºåœ°åœ–
    const newTiles = Array(BOARD_SIZE).fill(null).map((_, i) => ({ id: i, type: 'empty' }));
    
    // 0 æ˜¯èµ·é»
    newTiles[0] = { id: 0, type: 'start', label: 'èµ·é»' };

    // è¨­å®šç‰¹æ®Šæ ¼å­çš„ä½ç½® (æ©Ÿæœƒ/å‘½é‹) - å›ºå®šé–“éš”ï¼Œé˜²æ­¢ç›¸é€£
    // ç¸½å…±28æ ¼ï¼Œ0æ˜¯èµ·é»ï¼Œå‰©27æ ¼ã€‚æ”¾7å€‹ç‰¹æ®Šæ ¼ã€‚
    // æ¨¡å¼: 3, 7, 11, 15, 19, 23, 27 (é–“éš”3)
    const specialIndices = [3, 7, 11, 15, 19, 23, 27];
    
    // å¡«å……ç‰¹æ®Šæ ¼å­
    specialIndices.forEach((idx, i) => {
      newTiles[idx] = {
        id: idx,
        type: i % 2 === 0 ? 'chance' : 'fate', // äº¤æ›¿
        label: i % 2 === 0 ? 'æ©Ÿæœƒ' : 'å‘½é‹'
      };
    });

    // å¡«å……æˆèªæ ¼å­ (å‰©ä¸‹çš„ä½ç½®)
    let idiomIdx = 0;
    for (let i = 1; i < BOARD_SIZE; i++) {
      if (newTiles[i].type === 'empty' && idiomIdx < selected.length) {
        const idiom = selected[idiomIdx];
        newTiles[i] = { 
          id: i, 
          type: 'idiom', 
          data: idiom,
          price: 300, 
          rent: 150,  
          owner: null,
          houses: 0
        };
        idiomIdx++;
      }
    }

    setBoardTiles(newTiles);
    setStudyIndex(0);
    setPlayers({
      1: { pos: 0, score: INITIAL_SCORE, name: 'ç©å®¶ 1', color: 'bg-red-500', bg: 'bg-red-50', border: 'border-red-500', text: 'text-red-700' },
      2: { pos: 0, score: INITIAL_SCORE, name: 'ç©å®¶ 2', color: 'bg-blue-500', bg: 'bg-blue-50', border: 'border-blue-500', text: 'text-blue-700' }
    });
    setTurn(1);
    setGameLog(["æº–å‚™é–‹å§‹ï¼Œè«‹å…ˆæº«ç¿’ï¼"]);
    setGameState('study');
  };

  const rollDice = async () => {
    if (isMoving || modalContent) return;
    
    const roll = Math.floor(Math.random() * 6) + 1;
    setDiceValue(roll);
    setIsMoving(true);

    let currentPos = players[turn].pos;
    for (let i = 0; i < roll; i++) {
      await new Promise(r => setTimeout(r, 200));
      currentPos = (currentPos + 1) % BOARD_SIZE;
      
      setPlayers(prev => ({
        ...prev,
        [turn]: { ...prev[turn], pos: currentPos }
      }));

      if (currentPos === 0) {
        addLog(`${players[turn].name} ç¶“éèµ·é»ï¼Œ+300åˆ†`);
        setPlayers(prev => ({
          ...prev,
          [turn]: { ...prev[turn], score: prev[turn].score + 300, pos: currentPos }
        }));
      }
    }

    setIsMoving(false);
    handleTileEvent(currentPos);
  };

  const generateOptions = (correctData) => {
    const distractors = sessionIdioms
      .filter(i => i.id !== correctData.id)
      .sort(() => 0.5 - Math.random())
      .slice(0, 3);
    return [...distractors, correctData].sort(() => 0.5 - Math.random());
  };

  // --- è¨ˆç®—é€£é–ç§Ÿé‡‘ ---
  const calculateChainRent = (centerIndex, ownerId, tiles) => {
    let totalRent = 0;
    let connectedCount = 0;

    // Helper to get rent of a single tile
    const getRent = (t) => {
      const multiplier = t.houses === 0 ? 1 : (t.houses === 1 ? 2 : 4);
      return t.rent * multiplier;
    };

    // æª¢æŸ¥ä¸­å¿ƒé»
    const centerTile = tiles[centerIndex];
    totalRent += getRent(centerTile);
    connectedCount++;

    // å‘å‰æª¢æŸ¥ (Index - 1)
    let prev = centerIndex - 1;
    while (prev > 0) { // 0æ˜¯èµ·é»ï¼Œä¸èƒ½è·¨è¶Š
      const t = tiles[prev];
      if (t.type === 'idiom' && t.owner === ownerId) {
        totalRent += getRent(t);
        connectedCount++;
        prev--;
      } else {
        break; 
      }
    }

    // å‘å¾Œæª¢æŸ¥ (Index + 1)
    let next = centerIndex + 1;
    while (next < BOARD_SIZE) {
      const t = tiles[next];
      if (t.type === 'idiom' && t.owner === ownerId) {
        totalRent += getRent(t);
        connectedCount++;
        next++;
      } else {
        break;
      }
    }

    return { totalRent, connectedCount };
  };

  const handleTileEvent = (pos) => {
    const tile = boardTiles[pos];
    
    if (tile.type === 'idiom') {
      if (tile.owner === null) {
        // è²·åœ°
        const options = generateOptions(tile.data);
        setCurrentEvent({ ...tile, options, mode: 'buy' });
        setModalContent('question');

      } else if (tile.owner !== turn) {
        // --- å°æ±ºæ¨¡å¼ (è¸©ä¸­å°æ‰‹) + é€£é–è¨ˆç®— ---
        const { totalRent, connectedCount } = calculateChainRent(pos, tile.owner, boardTiles);
        
        setCurrentEvent({ 
          ...tile, 
          mode: 'duel', 
          currentRent: totalRent, // é€™æ˜¯é€£é–å¾Œçš„ç¸½åƒ¹
          connectedCount 
        });
        setModalContent('duel_alert');
      } else {
        // è‡ªå·±çš„åœ° - å»ºå±‹
        if (tile.houses < 2) {
          if (players[turn].score >= BUILD_COST) {
            setCurrentEvent({ ...tile, mode: 'build' });
            setModalContent('build_confirm');
          } else {
            addLog("è³‡é‡‘ä¸è¶³ï¼Œç„¡æ³•å‡ç´šæˆ¿å±‹ã€‚");
            switchTurn();
          }
        } else {
          addLog("æˆ¿å±‹å·²é”æœ€é«˜ç´šåˆ¥ã€‚");
          switchTurn();
        }
      }

    } else if (tile.type === 'chance' || tile.type === 'fate') {
      const isChance = tile.type === 'chance';
      const points = isChance ? 200 : -100;
      const texts = isChance 
        ? ["æ’¿åˆ°æˆèªç§˜ç±ï¼", "è€å¸«ç¨±è®šä½ ï¼", "å¹¸é‹ä¸­çï¼"]
        : ["ä¸Šèª²ç™¼ç™½æ—¥å¤¢ã€‚", "å¿˜è¨˜å¸¶åŠŸèª²ã€‚", "æ¸¬é©—ä¸åˆæ ¼ã€‚"];
      
      const text = texts[Math.floor(Math.random() * texts.length)];
      setCurrentEvent({ title: isChance ? "æ©Ÿæœƒ" : "å‘½é‹", text, points });
      setModalContent('event');
    } else {
      switchTurn();
    }
  };

  const startDuelQuestion = () => {
    const tile = currentEvent;
    const options = generateOptions(tile.data);
    setCurrentEvent({ ...tile, options, mode: 'duel' }); 
    setModalContent('question');
  };

  const handleBuildConfirm = () => {
    setPlayers(prev => ({
      ...prev,
      [turn]: { ...prev[turn], score: prev[turn].score - BUILD_COST }
    }));
    setBoardTiles(prev => prev.map(t => 
      t.id === currentEvent.id ? { ...t, houses: t.houses + 1 } : t
    ));
    addLog(`${players[turn].name} å‡ç´šäº†æˆ¿å±‹ï¼(Lv.${currentEvent.houses + 1})`);
    speak("å‡ç´šæˆåŠŸï¼");
    playSfx('build');
    setModalContent(null);
    switchTurn();
  };

  const handleAnswer = (selectedId) => {
    const isCorrect = selectedId === currentEvent.data.id;
    
    if (currentEvent.mode === 'buy') {
      if (isCorrect) {
        addLog(`${players[turn].name} è²·åœ°æˆåŠŸï¼`);
        setBoardTiles(prev => prev.map(t => 
          t.id === currentEvent.id ? { ...t, owner: turn } : t
        ));
        setPlayers(prev => ({
          ...prev,
          [turn]: { ...prev[turn], score: prev[turn].score + 100 }
        }));
        speak("ç­”å°äº†ï¼");
        playSfx('correct');
        setModalContent('correct_buy');
      } else {
        addLog(`${players[turn].name} è²·åœ°å¤±æ•—ã€‚`);
        playSfx('wrong');
        setModalContent('wrong_buy');
      }
    } else if (currentEvent.mode === 'duel') {
      const opponent = turn === 1 ? 2 : 1;
      const baseRent = currentEvent.currentRent; // å·²ç¶“åŒ…å«äº†é€£é–ç¸½é¡
      let actualRent = 0;
      let resultType = '';

      if (isCorrect) {
        // æ–°è¦å‰‡ï¼šç­”å°ä»˜åŸåƒ¹ (100%)
        actualRent = baseRent;
        resultType = 'duel_win';
        speak("é˜²ç¦¦æˆåŠŸï¼");
        playSfx('correct');
        addLog(`é˜²ç¦¦æˆåŠŸï¼æ”¯ä»˜åŸåƒ¹ $${actualRent}`);
      } else {
        // æ–°è¦å‰‡ï¼šç­”éŒ¯ä»˜é›™å€ (200%)
        actualRent = baseRent * 2;
        resultType = 'duel_lose';
        playSfx('shatter'); 
        addLog(`é˜²ç¦¦å¤±æ•—ï¼é›™å€ç½°æ¬¾ $${actualRent}`);
      }

      setPlayers(prev => ({
        ...prev,
        [turn]: { ...prev[turn], score: Math.max(0, prev[turn].score - actualRent) },
        [opponent]: { ...prev[opponent], score: prev[opponent].score + actualRent }
      }));

      setCurrentEvent(prev => ({ ...prev, actualRent }));
      setModalContent(resultType);
    }
  };

  const switchTurn = () => {
    const allOwned = boardTiles.filter(t => t.type === 'idiom').every(t => t.owner !== null);
    if (allOwned) {
      setGameState('finished');
    } else {
      setTurn(prev => prev === 1 ? 2 : 1);
    }
  };

  const calculateTotal = (playerId) => {
    const cash = players[playerId].score;
    const propertyValue = boardTiles
      .filter(t => t.owner === parseInt(playerId))
      .reduce((sum, t) => sum + t.price + (t.houses * BUILD_COST), 0);
    return cash + propertyValue;
  };

  // --- UI Components ---
  
  const MenuScreen = () => (
    <div className="flex flex-col items-center justify-center min-h-[500px] p-8 space-y-8 bg-white rounded-xl shadow-2xl border-4 border-indigo-100 text-center animate-fade-in relative">
      <button 
        onClick={toggleMusic}
        className={`absolute top-4 right-4 p-2 rounded-full ${isMusicPlaying ? 'bg-indigo-600 text-white' : 'bg-gray-200 text-gray-500'}`}
      >
        {isMusicPlaying ? <Music size={24} /> : <VolumeX size={24} />}
      </button>

      <div className="flex gap-4 mb-4">
        <Home size={64} className="text-indigo-600" />
      </div>
      <div>
        <h1 className="text-4xl font-black text-indigo-900 tracking-tight mb-2">æˆèªå¤§å¯Œç¿ï¼šé€£é–æ”»é˜²</h1>
        <p className="text-xl text-gray-500 font-medium">é€£é–åœ°ç”¢ãƒ»é›™å€é¢¨éšªãƒ»çµ•å°åˆºæ¿€</p>
      </div>
      <div className="bg-orange-50 p-6 rounded-xl text-left max-w-md w-full border border-orange-200">
        <h3 className="font-bold text-orange-800 flex items-center gap-2 mb-3">
          <Link size={20}/> éŠæˆ²æ–°è¦å‰‡ï¼š
        </h3>
        <ul className="list-disc list-inside text-sm text-gray-700 space-y-2 font-medium">
          <li><span className="text-indigo-600 font-bold">é€£é–è¨ˆè²»</span>ï¼šè‹¥æ•µäººæ“æœ‰ç›¸é€£çš„åœ°ç›¤ï¼Œç½°æ¬¾å°‡ç–ŠåŠ è¨ˆç®— (ä¾‹å¦‚ 150+150+150)ã€‚</li>
          <li><ShieldCheck size={14} className="inline text-green-600"/> é˜²ç¦¦æˆåŠŸ (ç­”å°)ï¼š<span className="font-bold text-green-700">æ”¯ä»˜åŸåƒ¹</span> (100%)ã€‚</li>
          <li><ShieldAlert size={14} className="inline text-red-600"/> é˜²ç¦¦å¤±æ•— (ç­”éŒ¯)ï¼š<span className="font-bold text-red-700">ç½°é›™å€</span> (200%)ã€‚</li>
          <li className="text-xs text-gray-500 mt-2">*æ©Ÿæœƒèˆ‡å‘½é‹æ ¼å­å·²åˆ†é–‹ï¼Œä¸å†é€£çºŒå‡ºç¾ã€‚</li>
        </ul>
      </div>
      <button 
        onClick={() => {
          initGame();
          if (!isMusicPlaying) toggleMusic(); 
        }}
        className="w-full max-w-xs px-8 py-4 bg-gradient-to-r from-indigo-600 to-purple-600 text-white rounded-2xl font-bold text-xl shadow-xl hover:scale-105 transition-transform"
      >
        é–‹å§‹å°æˆ°
      </button>
    </div>
  );

  const StudyScreen = () => {
    const item = sessionIdioms[studyIndex];
    return (
      <div className="flex flex-col h-full bg-white rounded-xl shadow-xl overflow-hidden max-w-2xl mx-auto">
        <div className="bg-indigo-600 text-white p-4 flex justify-between items-center">
          <span className="font-bold flex items-center gap-2"><BookOpen/> æˆ°å‰ç‰¹è¨“ (å…±20é¡Œ)</span>
          <span className="bg-indigo-800 px-3 py-1 rounded-full text-xs font-mono">{studyIndex + 1} / {TARGET_IDIOMS_COUNT}</span>
        </div>
        <div className="flex-1 p-8 flex flex-col items-center justify-center text-center space-y-6">
          <div className="group relative cursor-pointer" onClick={() => speak(item.word)}>
            <div className="text-5xl font-black text-gray-800 mb-2 group-hover:text-indigo-600 transition-colors">{item.word}</div>
            <div className="absolute top-0 -right-8 text-indigo-400 opacity-50 group-hover:opacity-100 animate-pulse"><Volume2 size={24} /></div>
          </div>
          <div className="text-xl text-gray-600 font-medium leading-relaxed bg-gray-50 p-6 rounded-xl border border-gray-100 w-full">{item.meaning}</div>
        </div>
        <div className="p-6 bg-gray-50 flex justify-between">
          <button disabled={studyIndex === 0} onClick={() => setStudyIndex(i => i - 1)} className="px-6 py-2 rounded-lg font-bold text-gray-500 hover:bg-gray-200 disabled:opacity-30 transition">ä¸Šä¸€å€‹</button>
          {studyIndex < TARGET_IDIOMS_COUNT - 1 ? (
            <button onClick={() => setStudyIndex(i => i + 1)} className="px-6 py-2 bg-indigo-600 text-white rounded-lg font-bold hover:bg-indigo-700 transition flex items-center gap-2">ä¸‹ä¸€å€‹ <ArrowRight size={18} /></button>
          ) : (
            <button onClick={() => setGameState('game')} className="px-8 py-2 bg-green-600 text-white rounded-lg font-bold hover:bg-green-700 transition shadow-lg animate-bounce flex items-center gap-2">é€²å…¥æˆ°å ´ <Swords size={18} /></button>
          )}
        </div>
      </div>
    );
  };

  const RenderBoard = () => {
    const getGridPos = (index) => {
      if (index <= 7) return { row: 1, col: index + 1 };
      if (index <= 14) return { row: index - 6, col: 8 };
      if (index <= 21) return { row: 8, col: 8 - (index - 14) };
      return { row: 8 - (index - 21), col: 1 };
    };

    return (
      <div className="grid grid-cols-8 grid-rows-8 gap-1 w-full max-w-3xl aspect-square mx-auto bg-slate-100 p-2 rounded-xl shadow-inner border-4 border-slate-200 relative select-none">
        
        <button 
          onClick={toggleMusic}
          className={`absolute top-2 right-2 z-20 p-1.5 rounded-full shadow-md ${isMusicPlaying ? 'bg-white text-indigo-600' : 'bg-gray-200 text-gray-500'} opacity-80 hover:opacity-100`}
        >
          {isMusicPlaying ? <Music size={16} /> : <VolumeX size={16} />}
        </button>

        <div className="col-start-2 col-end-8 row-start-2 row-end-8 bg-white rounded-xl shadow-sm flex flex-col p-4 z-10 overflow-hidden">
          <div className="flex gap-2 mb-4">
            {[1, 2].map(pid => (
              <div key={pid} className={`flex-1 p-3 rounded-xl border-2 transition-all ${players[pid].bg} ${players[pid].border} ${turn === pid ? 'ring-4 ring-yellow-400 scale-105 shadow-md' : 'opacity-80'}`}>
                <div className={`font-bold ${players[pid].text} flex justify-between`}>
                  <span>{players[pid].name}</span>
                  {turn === pid && <span className="text-xs bg-yellow-400 text-yellow-900 px-1 rounded">å›åˆ</span>}
                </div>
                <div className="text-2xl font-black text-gray-800">${players[pid].score}</div>
                <div className="text-xs text-gray-500 flex items-center gap-1">
                   åœ°çš®: {boardTiles.filter(t=>t.owner===pid).length}
                </div>
              </div>
            ))}
          </div>
          <div className="bg-gray-50 rounded-lg p-2 h-20 overflow-y-auto mb-4 text-xs text-gray-600 border border-gray-100 font-mono">
            {gameLog.map((log, i) => <div key={i} className={i===0?'font-bold text-black':''}>{i===0?'> ':''}{log}</div>)}
          </div>
          <div className="flex-1 flex items-center justify-center">
             <button onClick={rollDice} disabled={isMoving || modalContent !== null} className={`w-24 h-24 rounded-2xl shadow-xl flex flex-col items-center justify-center text-white font-bold transition-all ${turn === 1 ? 'bg-red-500 hover:bg-red-600' : 'bg-blue-500 hover:bg-blue-600'} ${(isMoving || modalContent) ? 'opacity-50 cursor-not-allowed' : 'hover:scale-110 active:scale-95'}`}>
              {isMoving ? <div className="animate-spin text-3xl">ğŸ²</div> : <><Dices size={32}/><span className="mt-1">æ“²éª°å­</span></>}
             </button>
             {diceValue > 0 && !isMoving && <div className="ml-4 font-bold text-gray-400 text-xl">é»æ•¸: {diceValue}</div>}
          </div>
        </div>

        {boardTiles.map((tile, i) => {
          const pos = getGridPos(i);
          const p1Here = players[1].pos === i;
          const p2Here = players[2].pos === i;
          
          let bgClass = "bg-white";
          let borderClass = "border-gray-200";
          if (tile.type === 'start') bgClass = "bg-yellow-100";
          else if (tile.type === 'chance') bgClass = "bg-orange-100";
          else if (tile.type === 'fate') bgClass = "bg-purple-100";
          else if (tile.owner === 1) { bgClass = "bg-red-100"; borderClass = "border-red-400"; }
          else if (tile.owner === 2) { bgClass = "bg-blue-100"; borderClass = "border-blue-400"; }

          return (
            <div key={i} className={`relative flex flex-col items-center justify-center text-center rounded border text-[8px] md:text-[10px] font-bold overflow-hidden transition-colors ${bgClass} ${borderClass}`} style={{ gridRow: pos.row, gridColumn: pos.col }}>
              {tile.type === 'idiom' ? (
                <>
                  <span className={`leading-tight z-10 ${tile.owner ? (tile.owner === 1 ? 'text-red-800' : 'text-blue-800') : 'text-gray-600'}`}>{tile.data.word}</span>
                  {tile.owner && (
                     <div className={`absolute top-0 right-0 p-0.5 text-[7px] text-white rounded-bl ${tile.owner === 1 ? 'bg-red-500' : 'bg-blue-500'}`}>
                       ${tile.rent * (tile.houses === 0 ? 1 : tile.houses === 1 ? 2 : 4)}
                     </div>
                  )}
                  <div className="absolute top-0 left-0 flex space-x-0.5 p-0.5">
                    {Array.from({length: tile.houses}).map((_, hi) => (
                      <Home key={hi} size={8} className={tile.owner === 1 ? 'text-red-600 fill-red-600' : 'text-blue-600 fill-blue-600'} />
                    ))}
                  </div>
                </>
              ) : (
                 <span className="opacity-60">{tile.label}</span>
              )}
              <div className="absolute bottom-0 w-full flex justify-center gap-1 pb-0.5">
                {p1Here && <div className="w-2 h-2 md:w-3 md:h-3 bg-red-500 rounded-full border border-white shadow-sm z-20"></div>}
                {p2Here && <div className="w-2 h-2 md:w-3 md:h-3 bg-blue-500 rounded-full border border-white shadow-sm z-20"></div>}
              </div>
            </div>
          );
        })}
      </div>
    );
  };

  const Modal = () => {
    if (!modalContent) return null;
    const isRed = turn === 1;
    const themeColor = isRed ? 'red' : 'blue';

    return (
      <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4 backdrop-blur-sm animate-fade-in">
        <div className={`bg-white rounded-2xl shadow-2xl w-full max-w-md overflow-hidden border-4 border-${themeColor}-200`}>
          
          {/* å»ºå±‹ç¢ºèª */}
          {modalContent === 'build_confirm' && (
            <div className="p-8 text-center bg-indigo-50">
              <Home size={64} className="mx-auto text-indigo-500 mb-4" />
              <h3 className="text-2xl font-black text-indigo-900 mb-2">å‡ç´šåœ°ç›¤ï¼Ÿ</h3>
              <p className="text-gray-700 mb-6">
                èŠ±è²» <span className="font-bold text-red-600">${BUILD_COST}</span> å»ºé€ ä¸€é–“æˆ¿å±‹ï¼Ÿ<br/>
                ç•¶å‰æˆ¿å±‹: {currentEvent.houses} / 2<br/>
                <span className="text-sm text-gray-500">å‡ç´šå¾Œï¼Œæ•µäººè¸©ä¸­æ‡²ç½°å°‡å€å¢ï¼</span>
              </p>
              <div className="flex gap-4">
                <button onClick={() => { setModalContent(null); switchTurn(); }} className="flex-1 py-3 bg-gray-300 text-gray-700 rounded-xl font-bold hover:bg-gray-400">ä¸äº†</button>
                <button onClick={handleBuildConfirm} className="flex-1 py-3 bg-indigo-600 text-white rounded-xl font-bold hover:bg-indigo-700 shadow-lg">ç¢ºèªå»ºé€ </button>
              </div>
            </div>
          )}

          {/* è¸©ä¸­å°æ‰‹è­¦å‘Š */}
          {modalContent === 'duel_alert' && (
            <div className="p-8 text-center bg-red-50">
              <ShieldAlert size={64} className="mx-auto text-red-500 mb-4 animate-pulse" />
              <h3 className="text-2xl font-black text-red-800 mb-2">å±éšªï¼è¸©ä¸­å°æ‰‹åœ°ç›¤ï¼</h3>
              <div className="text-gray-700 mb-4">
                <p>é€™æ˜¯ <strong>{players[isRed?2:1].name}</strong> çš„é ˜åœ°ã€‚</p>
                {currentEvent.connectedCount > 1 && (
                  <div className="inline-flex items-center gap-1 bg-red-100 text-red-800 px-2 py-1 rounded mt-2 font-bold">
                    <Link size={16}/> {currentEvent.connectedCount} é€£é–åœ°ç›¤ï¼
                  </div>
                )}
              </div>
              
              <div className="bg-white p-4 rounded-xl border border-red-200 mb-6 text-sm text-left space-y-2">
                <div className="flex items-center justify-between gap-2 font-bold text-lg border-b pb-2">
                   <span>é€£é–ç¸½ç§Ÿé‡‘:</span>
                   <span className="text-red-600">${currentEvent.currentRent}</span>
                </div>
                <div className="flex items-center gap-2 text-green-700 pt-2"><ShieldCheck size={16}/> ç­”å°: æ”¯ä»˜åŸåƒ¹ (${currentEvent.currentRent})</div>
                <div className="flex items-center gap-2 text-red-700"><ShieldAlert size={16}/> ç­”éŒ¯: é›™å€ç½°æ¬¾ (${currentEvent.currentRent*2})</div>
              </div>
              <button onClick={startDuelQuestion} className="w-full py-3 bg-red-600 text-white rounded-xl font-bold hover:bg-red-700 shadow-lg">æ¥å—æŒ‘æˆ°</button>
            </div>
          )}

          {/* å•é¡Œç•Œé¢ */}
          {modalContent === 'question' && (
            <div className="p-6">
              <div className="flex justify-between items-center mb-4">
                <span className={`px-3 py-1 rounded-full text-xs font-bold text-white bg-${themeColor}-500`}>{players[turn].name} çš„å›åˆ</span>
                <span className="text-gray-400 text-xs font-bold">{currentEvent.mode === 'buy' ? 'ä½”é ˜æ¨¡å¼' : 'é˜²ç¦¦æ¨¡å¼'}</span>
              </div>
              <div className="mb-6">
                <p className="text-gray-500 text-xs mb-2">æˆèªæ„æ€ï¼š</p>
                <div className="text-lg font-bold text-gray-800 bg-gray-50 p-4 rounded-lg border-l-4 border-indigo-500">{currentEvent.data.meaning}</div>
              </div>
              <div className="grid gap-3">
                {currentEvent.options.map((opt, idx) => (
                  <button 
                    key={idx} 
                    onClick={() => handleAnswer(opt.id)} 
                    className="p-4 rounded-xl border-2 border-gray-200 bg-white hover:bg-gray-50 hover:border-gray-300 text-left font-bold text-gray-700 active:scale-98 transition-all"
                  >
                    {opt.word}
                  </button>
                ))}
              </div>
            </div>
          )}

          {/* çµæœåé¥‹ */}
          {['correct_buy', 'wrong_buy', 'duel_win', 'duel_lose', 'event'].includes(modalContent) && (
            <div className="p-8 text-center bg-white">
              <div className="mb-4 flex justify-center">
                {modalContent === 'correct_buy' && <Star size={48} className="text-yellow-400"/>}
                {modalContent === 'wrong_buy' && <Trophy size={48} className="text-gray-300"/>}
                {modalContent === 'duel_win' && <ShieldCheck size={48} className="text-green-500"/>}
                {modalContent === 'duel_lose' && <ShieldAlert size={48} className="text-red-500"/>}
                {modalContent === 'event' && <Dices size={48} className="text-indigo-500"/>}
              </div>
              <h3 className="text-2xl font-bold mb-2 text-gray-800">
                {modalContent === 'correct_buy' && "ä½”é ˜æˆåŠŸï¼"}
                {modalContent === 'wrong_buy' && "ä½”é ˜å¤±æ•—..."}
                {modalContent === 'duel_win' && "é˜²ç¦¦æˆåŠŸï¼"}
                {modalContent === 'duel_lose' && "é˜²ç¦¦å¤±æ•—ï¼"}
                {modalContent === 'event' && currentEvent.title}
              </h3>
              <p className="text-gray-600 mb-6">
                 {modalContent === 'duel_win' && `é˜²ç¦¦æˆåŠŸï¼ä½†å› ç‚ºé€™æ˜¯å°æ–¹çš„åœ°ç›¤ï¼Œä½ ä»éœ€æ”¯ä»˜åŸåƒ¹ç§Ÿé‡‘ $${currentEvent.actualRent}ã€‚`}
                 {modalContent === 'duel_lose' && `é˜²ç¦¦å¤±æ•—ï¼ä½ éœ€è¦æ”¯ä»˜é›™å€ç§Ÿé‡‘ $${currentEvent.actualRent}ï¼`}
                 {modalContent === 'wrong_buy' && `æ­£ç¢ºç­”æ¡ˆæ˜¯ï¼š${currentEvent.data.word}`}
                 {modalContent === 'event' && `${currentEvent.text} (${currentEvent.points > 0 ? '+' : ''}${currentEvent.points}åˆ†)`}
                 {modalContent === 'correct_buy' && "ç²å¾—åœ°çš®åŠçå‹µï¼"}
              </p>
              <button onClick={() => { setModalContent(null); switchTurn(); }} className={`w-full py-3 bg-${themeColor}-600 text-white rounded-xl font-bold hover:bg-${themeColor}-700`}>ç¢ºå®š</button>
            </div>
          )}
        </div>
      </div>
    );
  };

  const FinishedScreen = () => {
    const p1Total = calculateTotal(1);
    const p2Total = calculateTotal(2);
    const winner = p1Total > p2Total ? 1 : (p2Total > p1Total ? 2 : 0);
    return (
      <div className="flex flex-col items-center justify-center min-h-[500px] p-8 text-center space-y-6 bg-white rounded-xl shadow-lg border-4 border-yellow-200">
        <Crown size={80} className="text-yellow-400 drop-shadow-lg" />
        <h2 className="text-4xl font-black text-indigo-900">å°æˆ°çµæŸï¼</h2>
        <div className="flex gap-4 w-full max-w-lg justify-center mt-4">
          {[1, 2].map(pid => (
            <div key={pid} className={`flex-1 p-4 rounded-xl border-4 ${winner === pid ? 'border-yellow-400 bg-yellow-50 scale-105' : 'border-gray-100 bg-gray-50'}`}>
              <div className={`text-xl font-bold ${pid===1?'text-red-700':'text-blue-700'}`}>ç©å®¶ {pid}</div>
              <div className="text-3xl font-black text-gray-800">${pid===1?p1Total:p2Total}</div>
            </div>
          ))}
        </div>
        <div className="text-2xl font-bold text-indigo-600 mt-6 animate-bounce">{winner === 0 ? "å¹³æ‰‹ï¼" : `æ­å–œ ${players[winner].name} ç²å‹ï¼`}</div>
        <button onClick={initGame} className="px-8 py-3 bg-indigo-600 text-white rounded-xl font-bold text-lg shadow-lg hover:bg-indigo-700 transition">å†ä¾†ä¸€å±€</button>
      </div>
    );
  };

  return (
    <div className="min-h-screen bg-slate-100 py-4 px-2 md:py-8 font-sans flex flex-col items-center">
      <div className="w-full max-w-4xl">
        {gameState === 'menu' && <MenuScreen />}
        {gameState === 'study' && <StudyScreen />}
        {gameState === 'game' && <RenderBoard />}
        {gameState === 'finished' && <FinishedScreen />}
      </div>
      <Modal />
    </div>
  );
}
